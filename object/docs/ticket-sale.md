# 티켓 판매 애플리케이션 구현하기

## 배경 설명

소극장의 홍보를 위해 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송하고, 공연날 이벤트에 당첨된 관람객과 그렇지 못한 관람객을 다른 방식으로 입장시켜야 한다.

이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후에 입장할 수 있고, 이벤트에 당첨되지 않은 관람객은 티켓을 구매해야만 입장할 수 있다.

## 요구사항 분석

1. 관람객을 입장시키기 전 이벤트 당첨 여부를 파악한다.
   1. 이벤트 당첨자인 경우 초대장을 티켓으로 교환한다.
   2. 이벤트 당첨자가 아닌 경우 티켓을 판매해야 한다.
2. 티켓이 있는 고객만 입장할 수 있다.

## [c3dfdd67c78e823cd07f1d701a1a3cfaeeca832f 커밋](https://github.com/ksundong/oop-lab/commit/c3dfdd67c78e823cd07f1d701a1a3cfaeeca832f)의 문제점

`Theater` 클래스의 `enter` 메서드의 문제점은 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재가 되었다는 점이다. 만약 우리가 관람객이라면, 소극장이라는 제 3자가 내 가방을 마음대로 열어보고,
뒤적이고, 돈을 가져간다는 데에 있다.  
판매소도 잘 생각해보면, 소극장이 매표소에 보관중인 티켓과 현금에 마음대로 접근할 수 있다. 더 큰 일은 이를 소극장이 수행하고, 판매소는 그냥 가만히 있는 것이다.

이 코드를 이해하기 어려운 또 다른 이유는, 세부적인 내용까지 모두 알고있어야 한다는 점에 있다. 결국 코드를 작성하는 사람과, 읽는 사람 모두가 큰 부담을 지게된다.

제일 큰 문제는, `Theater`가 `Audience`, `TicketSeller`가 변경될 경우 함께 변경된다는 점이다. 요구사항은 언제든 변경될 수 있다. 가령 신용카드를 통해 결제한다고 한다면, 어떻게
되는걸까? 사용자가 가방을 가지고 있지 않다면 어떻게 해야 하는걸까?  
즉, 이 코드는 지나치게 세부적인 사실에 의존한다.  
세부적인 사실에 의존하게 되면, 결국 이것이 변경되면, 함께 변경되어야 한다는 것이다. 다른 클래스가 내부에 대해서 더 많이 알면 알 수록 더 변경하기 어려워진다.

이는 객체 사이의 의존성(dependency)과 관련된 문제다. 의존성은 결국 변경과 관련되어 있고, 의존성은 변경에 대한 영향을 암시한다.  
의존성이라는 말 속에는 어떤 객체가 변경될 때, 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포되어 있다.

그렇다고, 객체 사이의 의존성을 완전히 없애는 것은 정답이 아니다. 객체지향 설계는 서로 의존하면서 협력하는 객체의 공동체를 구축하는 것이다.  
따라서 우리의 목표는 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성을 유지하고, 불필요한 의존성을 제거하는 것이다.

객체사이의 의존성이 과한 경우를 결합도(coupling)가 높다고 말한다. 반대로 합리적인 수준의 의존성이 유지되고 있다면, 결합도가 낮다고 한다.  
결국 결합도가 높을수록 변경에 취약해지고, 어려워진다.  
따라서 설계의 목표는 객체사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 한다.
